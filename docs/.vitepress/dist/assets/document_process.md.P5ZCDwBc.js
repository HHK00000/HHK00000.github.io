import{_ as l,c as e,o as i,ae as t}from"./chunks/framework.Dh1jimFm.js";const _=JSON.parse('{"title":"进程与线程","description":"","frontmatter":{},"headers":[],"relativePath":"document/process.md","filePath":"document/process.md"}'),r={name:"document/process.md"};function o(s,a,n,c,d,h){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="进程与线程" tabindex="-1">进程与线程 <a class="header-anchor" href="#进程与线程" aria-label="Permalink to &quot;进程与线程&quot;">​</a></h1><h2 id="进程与线程的概念" tabindex="-1">进程与线程的概念 <a class="header-anchor" href="#进程与线程的概念" aria-label="Permalink to &quot;进程与线程的概念&quot;">​</a></h2><ul><li>进程是资源分配的最小单位 线程是程序执行的最小单位 是CPU调度的基本单位</li><li>进程有自己独立的地址空间 每启动一个进程 系统都会为其分配地址空间 建立数据表来维护代码段、堆栈端和数据段 线程没有独立的地址空间 它们使用相同的地址空间共享数据</li><li>创建一个线程比创建一个进程开销小 CPU切换一个线程比切换进程花费小 线程占用的资源要比进程少很多</li><li>线程间通信更方便 同一个进程下 线程共享全局变量、静态变量等数据 进程之间的通信需要以通信的方式(IPC)进行 (但多线程程序处理好同步与互斥是个难点)</li><li>多进程程序更安全 生命力更强 一个进程死掉不会对另一个进程造成影响(源于有独立的地址空间) 多线程程序更不易维护 一个线程死掉 整个进程就死掉了(因为共享地址空间)</li><li>进程对资源保护要求高 开销大 效率相对较低 线程资源保护要求不高 但开销小 效率高 可频繁切换</li><li>java内存模型(Java Memory Model，JMM)</li></ul><h2 id="浏览器的进程与线程" tabindex="-1">浏览器的进程与线程 <a class="header-anchor" href="#浏览器的进程与线程" aria-label="Permalink to &quot;浏览器的进程与线程&quot;">​</a></h2><ul><li>浏览器是多进程的，浏览器的每一个 tab标签都代表一个独立的进程（有时候多个空白tab会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种</li></ul><h3 id="浏览器每个进程有多个线程-主要有以下线程" tabindex="-1">浏览器每个进程有多个线程，主要有以下线程： <a class="header-anchor" href="#浏览器每个进程有多个线程-主要有以下线程" aria-label="Permalink to &quot;浏览器每个进程有多个线程，主要有以下线程：&quot;">​</a></h3><ul><li>GUI渲染线程：负责渲染页面，解析HTML、CSS、生成DOM树等，当页面重绘或者回流时都会调起该线程 <ul><li>GUI渲染线程和JS引擎线程是互斥的，当JS引擎线程在工作的时候，GUI渲染线程会被挂起，GUI更新会被放入JS任务队列中，等待JS引擎线程空闲的时候继续执行</li></ul></li><li>JS引擎线程：单线程工作，负责解析运行JavaScript脚本，和GUI渲染线程互斥，JS运行耗时过长就会导致页面阻塞</li><li>事件触发线程：当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待JS引擎处理</li><li>定时器触发线程：浏览器定时计数器并不是由JS引擎计数的，阻塞会导致计时不准确，开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待JS引擎处理</li><li>http请求线程：http请求的时候会开启一条请求线程，请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待JS引擎处理</li></ul>',7)]))}const p=l(r,[["render",o]]);export{_ as __pageData,p as default};
